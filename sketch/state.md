# Mutable Shared State

When state is both mutable and shared, even single-threaded programming [causes problems](https://groups.google.com/a/dartlang.org/forum/#!topic/misc/3wUeZvYQQFo/discussion) (that discussion thread has some great discussion about asynchronous programming primitives).  Here are a few lessons learned:

  * when a user says “foo should be explicit” what he really means is “I want an easy way to detect foo” (see Justin Fagnani’s comments about explicit `await`).  In my view, tooling is almost always better than explicit syntax.  Syntax is for conveying programmer intent.  Certainly a programmer doesn’t want to await anything.  He wants to use a value.  Awaiting is an extraneous implementation detail about which he only sometimes cares.  When he cares, he can run a tool to find out (via static analysis, profiling, etc).
  * it’s worth thinking about the interaction between async code and side effecting code. a tool should be able to statically detect when they occur together. it makes me think this is one more reason to avoid side effecting code as much as possible
  * programming is very subjective.  Justin says, “You could accidentally call an expensive blocking function inside a node-like context” but he doesn’t advocate for a keyword that marks computationally expensive operations or marks downstream calls to print().
  * explicit syntax is viral (see Christopher Wright’s comments) because everyone up the call stack has to change his code to be explicit.  no such changes are required for implicit constructs.
  * mutable state is horrible, horrible stuff.  Look at Justin’s Dart example with explicit Futures and the questions he raises.  Each question is only a problem because `Greeter.message` is mutable

Prolog generally avoids mutable state entirely.  Unbound variables aren’t so much mutable as they are “doesn’t have a value yet”, just like lazy variables in Haskell.  Unfortunately, Prolog does have global, mutable flags.  Some Prolog programs also use the database as a global, mutable state storage facility.  Both of these problems need to be tamed somehow.

Many dynamic languages suffer from code as shared, mutable state.  I’ve seen both Perl and Prolog modules which behave differently depending on which other modules are loaded at run time.

Many Prolog implementations have way too much global state for configuration.  For example, SWI Prolog has `set_prolog_flag/2`, `portray_text/1`, `style_check/1`, etc.  If a clause wants to change `style_check` behavior locally, it has to figure out the current state, set it to a new state, restore the old state.  Of course doing any of that from inside a macro often requires much more effort.  One should be able to set these configuration items lexically.  Perl’s `no warnings` mechanism is helpful in this regard.


# State

Any Prolog variant should have something like Mercury's state variables to make variables `Foo0`, `Foo1`, `Foo2`, etc more palatable. They're kind of like pipes for data to flow through, so perhaps use a `|` character to denote them. They're also like automatically numbered variables using a base name, so a `#` character is also appropriate.  Mercury uses `!` to denote them (suggesting danger?).  Mercury's state variables work well in many cases. The only problem with them is that they impose an order on goals which prevents goals from being reordered (often requiring clauses that vary only in their goal order). I ran into this problem repeatedly while working on "tp".  It'd be cool to have two variants of state variables: one that imposes order and one that leaves the compiler free to reorder goals. It's like pipes that can flow in only one direction and pipes that can flow into multiple directions. That suggests `|` for one direction (only one line) and `#` for multiple directions (many lines).

It's often convenient to implicitly thread state variables through a predicate. DCG notation is the best known example. [Aquarius Prolog](http://www.info.ucl.ac.be/~pvr/aquarius.html) has [Extended DCG Notation](http://www.info.ucl.ac.be/~pvr/Peter.thesis/Peter.thesis.html) which allows one to thread multiple state variables through a predicate. In some sense, all Prolog predicates implicitly thread a database through the goals. It's the database against which they seek goals. Mercury performs IO by threading a "state of the world" through predicates that perform IO. Haskell monads are often used to make State threading implicit. The high level observation is that programmers don't like to perform bookkeeping on this state. Perhaps there can be a way for a predicate to declare "I need access to the following state: database, DCG and IO". The compiler  implicitly adds arguments to the predicate for that state. Some predicates only need to read the state. Others need to create new state. Some need to do both. I don't quite know how this will look, but it seems like a problem worth addressing.
