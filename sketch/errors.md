# Error Handling

I don't think exceptions are fundamental enough.  They can be implemented in terms of condition and restart.  I need to spend more time working with Common Lisp's condition and restart system to understand if it's really as flexible and productive as I think it is.  See my [previous thoughts](http://blog.ndrix.com/2013/02/programming-for-failure.html) about error handling.


Joel Spolsky makes [some reasonable arguments](http://www.joelonsoftware.com/items/2003/10/13.html) that exceptions (and by extension, condition-restart) should be considered more harmful than GOTO statements.  Besides his criticism of exceptions, he raises some interesting questions about how errors should be handled:

  * how well does the error handling mechanism get out of the way
    when one is prototyping or otherwise doesn't care about errors
  * how well does error handling compose (see `g(f(x))` example)


Condition and restart seems like the same failure handling mechanism that has developed repeatedly in complex systems in the real world.  Businesses have managers to whom problems are delivered; they can address them with a broader perspective on the businesses needs.  Communities have elders/chiefs/judges to whom difficult questions can be brought for resolution; they address the problem with a broader level of experience/knowledge than those facing the problem.  I vaguely recall that our brains have a similar, multi-tier architecture for handling unexpected/novel inputs.

The fundamental idea behind condition-restart seems simple.  When code encounters a circumstance it can't deal with, it asks someone else for additional information.  That information resolves the circumstance into something it can deal with.

It's interesting to note that in Common Lisp, handlers can modify the condition on its way up the call stack.  For example, [this tutorial](http://chaitanyagupta.com/lisp/restarts.html) modifies the condition by adding a line number.  It doesn't stop the condition; just adjusts it a little before it proceeds upward.  That same tutorial suggests value in allowing handlers to track state (count signals received, for example).

Kent Pitman [describes condition-restart](http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html) as a protocol by which independent pieces of code may communicate.  This suggests that a function and its ancestral callers can be thought of as independent nodes in a network.  In the general case, they're working together and must cooperate.  The common case is for ancestor to communicate a single message to the function (calling it) and the function communicates a single message back to the ancestor (returning a value).  Because that's the common case, nearly all languages provide convenient support for it.  Common Lisp acknowledges that in certain occasions, the communication requires more than a single message.  This is conceptually similar to the difference between static web pages (single request and response) and dynamic web pages (request + AJAX requests).

Kent also sees value in asking the condition what restarts are acceptable.  This kind of reflection allows a top-level, for example, to ask the user how he wants to handle a condition.  I imagine this would be quite helpful during debugging and prototyping.  Ideally, the list of acceptable conditions can be inferred from the context in which the condition is signaled.  I believe this is done in Common Lisp with `restart-case` which can signal the error and perform a switch on the resulting restart.  The switch cases are used as the list of acceptable restarts for that condition.

In Prolog, one can think of an exceptional situation as one in which the program tree has several branches and the code is not sure which one it should take.  A restart provides sufficient information that the code can choose one of those branches.  Prolog variants encounter similar scenarios all the time and they just explore each branch and backtrack if it's wrong.  In that circumstance, errors are handled by teaching Prolog what "wrong" means.  In many scenarios that works fine.  However, if one can't backtrack out of a branch (due to side effects, etc.), one must be certain which branch is the right one before pursuing it.

When code signals a condition, it's asking its ancestors in the call tree for help resolving the condition.  This is like asking the ancestors to evaluate a predicate `help_me(+Condition,-Guidance)` which binds `Guidance` to one of `go(Restart)`, `adjustment(NewCondition)`, `unwind_call_stack`, etc. or fails if it can offer no help.  This leaves open the question: how do the ancestors contribute to defining this predicate.  We could have each ancestor give its own definition of the predicate and evaluate those predicates from most specific to most general ancestor (as Common Lisp does).  We could have each ancestor contribute clauses to a dynamically scoped `help_me/2` predicate which is evaluated by the signaler.  Under that arrangement, we'd probably want clauses from the most specific ancestor to come before those from the most general ancestor.

Kent Pitman's paper (above) suggests an interesting idea that might be applicable in Amalog: instead of having an ancestor return a single restart, it could return a set of constraints which the branches must satisfy.  Choosing a single restart is a specific case in which the constraint is `Restart=foo`.  Although the generality and power of the idea is enticing, I'd have to see some real use cases for this before adopting it.

Should one who signals a condition be allowed to specify a default action to take if none of the call stack ancestors choose a restart for him?  The default might be to stop the program with an error message or it might be to guess at a reasonable way forward.
